<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Memory protection: controlling automatic materialization</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Memory protection: controlling automatic
materialization</h1>



<p>Unlike traditional data frames, duckplyr defers computation until
absolutely necessary, allowing DuckDB to optimize execution. This
article explains how to control the materialization of data to maintain
a seamless dplyr-like experience while remaining cautious of memory
usage.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(conflicted)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="fu">conflict_prefer</span>(<span class="st">&quot;filter&quot;</span>, <span class="st">&quot;dplyr&quot;</span>)</span></code></pre></div>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>From a user’s perspective, data frames backed by duckplyr, with class
<code>&quot;duckplyr_df&quot;</code>, behave as regular data frames in almost all
respects. In particular, direct column access like <code>df$x</code>, or
retrieving the number of rows with <code>nrow()</code>, works
identically. Conceptually, duckplyr frames are “eager”:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>df <span class="ot">&lt;-</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  duckplyr<span class="sc">::</span><span class="fu">duckdb_tibble</span>(<span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>) <span class="sc">|&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">y =</span> x <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>df</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a><span class="fu">class</span>(df)</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>df<span class="sc">$</span>y</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a><span class="fu">nrow</span>(df)</span></code></pre></div>
<p>Under the hood, two key differences provide improved performance and
usability:</p>
<ul>
<li><strong>lazy materialization</strong>: Unlike traditional data
frames, duckplyr defers computation until absolutely necessary,
i.e. lazily, allowing DuckDB to optimize execution.</li>
<li><strong>prudence</strong>: Automatic materialization is
controllable, as automatic materialization of large data might otherwise
inadvertently lead to memory problems.</li>
</ul>
<p>The term “prudence” is introduced here to set a clear distinction
from the concept of “laziness”, and because “control of automatic
materialization” is a mouthful.</p>
</div>
<div id="eager-and-lazy-computation" class="section level2">
<h2>Eager and lazy computation</h2>
<p>For a duckplyr frame that is the result of a dplyr operation,
accessing column data or retrieving the number of rows will trigger a
computation that is carried out by DuckDB, not dplyr. In this sense,
duckplyr frames are also “lazy”: the computation is deferred until the
last possible moment, allowing DuckDB to optimize the whole
pipeline.</p>
<div id="example" class="section level3">
<h3>Example</h3>
<p>This is explained in the following example that computes the mean
arrival delay for flights departing from Newark airport (EWR) by day and
month:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>flights <span class="ot">&lt;-</span> duckplyr<span class="sc">::</span><span class="fu">flights_df</span>()</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>flights_duckdb <span class="ot">&lt;-</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>  flights <span class="sc">|&gt;</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>  duckplyr<span class="sc">::</span><span class="fu">as_duckdb_tibble</span>()</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a><span class="fu">system.time</span>(</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>  mean_arr_delay_ewr <span class="ot">&lt;-</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>    flights_duckdb <span class="sc">|&gt;</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>    <span class="fu">filter</span>(origin <span class="sc">==</span> <span class="st">&quot;EWR&quot;</span>, <span class="sc">!</span><span class="fu">is.na</span>(arr_delay)) <span class="sc">|&gt;</span></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a>    <span class="fu">summarize</span>(</span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>      <span class="at">.by =</span> month,</span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a>      <span class="at">mean_arr_delay =</span> <span class="fu">mean</span>(arr_delay),</span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a>      <span class="at">min_arr_delay =</span> <span class="fu">min</span>(arr_delay),</span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a>      <span class="at">max_arr_delay =</span> <span class="fu">max</span>(arr_delay),</span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a>      <span class="at">median_arr_delay =</span> <span class="fu">median</span>(arr_delay),</span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a>    )</span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a>)</span></code></pre></div>
<p>Setting up the pipeline is fast, the size of the data does not affect
the setup costs. Because the computation is deferred, DuckDB can
optimize the whole pipeline, which can be seen in the output below:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>mean_arr_delay_ewr <span class="sc">|&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>  <span class="fu">explain</span>()</span></code></pre></div>
<p>The first step in the pipeline is to prune the unneeded columns, only
<code>origin</code>, <code>month</code>, and <code>arr_delay</code> are
kept. The result becomes available when accessed:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">system.time</span>(mean_arr_delay_ewr<span class="sc">$</span>mean_arr_delay[[<span class="dv">1</span>]])</span></code></pre></div>
</div>
<div id="comparison" class="section level3">
<h3>Comparison</h3>
<p>The functionality is similar to lazy tables in <a href="https://dbplyr.tidyverse.org/">dbplyr</a> and lazy frames in <a href="https://dtplyr.tidyverse.org/">dtplyr</a>. However, the behavior
is different: at the time of writing, the internal structure of a lazy
table or frame is different from a data frame, and columns cannot be
accessed directly.</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="center"><strong>Eager</strong> 😃</th>
<th align="center"><strong>Lazy</strong> 😴</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>dplyr</strong></td>
<td align="center">✅</td>
<td align="center"></td>
</tr>
<tr class="even">
<td><strong>dbplyr</strong></td>
<td align="center"></td>
<td align="center">✅</td>
</tr>
<tr class="odd">
<td><strong>dtplyr</strong></td>
<td align="center"></td>
<td align="center">✅</td>
</tr>
<tr class="even">
<td><strong>duckplyr</strong></td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
</tbody>
</table>
<p>In contrast, with <a href="https://dplyr.tidyverse.org/">dplyr</a>,
each intermediate step and also the final result is a proper data frame,
and computed right away, forfeiting the opportunity for
optimization:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="fu">system.time</span>(</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>  flights <span class="sc">|&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>    <span class="fu">filter</span>(origin <span class="sc">==</span> <span class="st">&quot;EWR&quot;</span>, <span class="sc">!</span><span class="fu">is.na</span>(arr_delay)) <span class="sc">|&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>    <span class="fu">summarize</span>(</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>      <span class="at">.by =</span> <span class="fu">c</span>(month, day),</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>      <span class="at">mean_arr_delay =</span> <span class="fu">mean</span>(arr_delay),</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>      <span class="at">min_arr_delay =</span> <span class="fu">min</span>(arr_delay),</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>      <span class="at">max_arr_delay =</span> <span class="fu">max</span>(arr_delay),</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>      <span class="at">median_arr_delay =</span> <span class="fu">median</span>(arr_delay),</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>    )</span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>)</span></code></pre></div>
<p>See also the <a href="https://duckdb.org/2024/04/02/duckplyr.html">duckplyr: dplyr
Powered by DuckDB</a> blog post for more information.</p>
</div>
</div>
<div id="prudence" class="section level2">
<h2>Prudence</h2>
<p>Being both “eager” and “lazy” at the same time introduces a
challenge: it is too easy to accidentally trigger computation, which is
prohibitive if an intermediate result is too large to fit into memory.
Prudence is a setting for duckplyr frames that limits the size of the
data that is materialized automatically.</p>
<div id="concept" class="section level3">
<h3>Concept</h3>
<p>Three levels of prudence are available:</p>
<ul>
<li><em>lavish</em> (careless about resources): always automatically
materialize, as in the first example.</li>
<li><em>stingy</em> (avoid spending at all cost): never automatically
materialize, throw an error when attempting to access the data.</li>
<li><em>thrifty</em> (use resources wisely): only automaticaly
materialize the data if it is small, otherwise throw an error.</li>
</ul>
<p>For lavish duckplyr frames, as in the two previous examples, the
underlying DuckDB computation is carried out upon the first request.
Once the results are computed, they are cached and subsequent requests
are fast. This is a good choice for small to medium-sized data, where
DuckDB can provide a nice speedup but materializing the data is
affordable at any stage. This is the default for
<code>duckdb_tibble()</code> and <code>as_duckdb_tibble()</code>.</p>
<p>For stingy duckplyr frames, accessing a column or requesting the
number of rows triggers an error. This is a good choice for large data
sets where the cost of materializing the data may be prohibitive due to
size or computation time, and the user wants to control when the
computation is carried out and where the results are stored. Results can
be materialized explicitly with <code>collect()</code> and other
functions.</p>
<p>Thrifty duckplyr frames are a compromise between lavish and stingy,
discussed further below.</p>
</div>
<div id="example-1" class="section level3">
<h3>Example</h3>
<p>Passing <code>prudence = &quot;stingy&quot;</code> to
<code>as_duckdb_tibble()</code> creates a stingy duckplyr frame.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>flights_stingy <span class="ot">&lt;-</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>  flights <span class="sc">|&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>  duckplyr<span class="sc">::</span><span class="fu">as_duckdb_tibble</span>(<span class="at">prudence =</span> <span class="st">&quot;stingy&quot;</span>)</span></code></pre></div>
<p>The data can be displayed, and column names and types can be
accessed.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>flights_stingy</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="fu">names</span>(flights_stingy)[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>]</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a><span class="fu">class</span>(flights_stingy)</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a><span class="fu">class</span>(flights_stingy[[<span class="dv">1</span>]])</span></code></pre></div>
<p>On the other hand, accessing a column or requesting the number of
rows triggers an error:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">nrow</span>(flights_stingy)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>flights_stingy[[<span class="dv">1</span>]]</span></code></pre></div>
<p>This means that stingy duckplyr frames can also be used to enforce
DuckDB operation for a pipeline.</p>
</div>
<div id="enforcing-duckdb-operation" class="section level3">
<h3>Enforcing DuckDB operation</h3>
<p>For operations not supported by duckplyr, the original dplyr
implementation is used as a fallback. As the original dplyr
implementation accesses columns directly, the data must be materialized
before a fallback can be executed. Therefore, stingy frames allow you to
check that all operations are supported by DuckDB: for a stingy frame,
fallbacks to dplyr are not possible.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>flights_stingy <span class="sc">|&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>  <span class="fu">group_by</span>(origin) <span class="sc">|&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">n =</span> <span class="fu">n</span>()) <span class="sc">|&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>  <span class="fu">ungroup</span>()</span></code></pre></div>
<p>The same pipeline with a lavish frame works, but the computation is
carried out by dplyr:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>flights_stingy <span class="sc">|&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>  duckplyr<span class="sc">::</span><span class="fu">as_duckdb_tibble</span>(<span class="at">prudence =</span> <span class="st">&quot;lavish&quot;</span>) <span class="sc">|&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>  <span class="fu">group_by</span>(origin) <span class="sc">|&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">n =</span> <span class="fu">n</span>()) <span class="sc">|&gt;</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>  <span class="fu">ungroup</span>()</span></code></pre></div>
<p>By using operations supported by duckplyr and avoiding fallbacks as
much as possible, your pipelines will be executed by DuckDB in an
optimized way.</p>
</div>
<div id="from-stingy-to-lavish" class="section level3">
<h3>From stingy to lavish</h3>
<p>A stingy duckplyr frame can be converted to a lavish one with
<code>as_duckdb_tibble(prudence = &quot;lavish&quot;)</code>. The
<code>collect.duckplyr_df()</code> method triggers computation and
converts to a plain tibble. The difference between the two is the class
of the returned object:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>flights_stingy <span class="sc">|&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>  duckplyr<span class="sc">::</span><span class="fu">as_duckdb_tibble</span>(<span class="at">prudence =</span> <span class="st">&quot;lavish&quot;</span>) <span class="sc">|&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>  <span class="fu">class</span>()</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>flights_stingy <span class="sc">|&gt;</span></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>  <span class="fu">collect</span>() <span class="sc">|&gt;</span></span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>  <span class="fu">class</span>()</span></code></pre></div>
<p>The same behavior is achieved with <code>as_tibble()</code> and
<code>as.data.frame()</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>flights_stingy <span class="sc">|&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>  <span class="fu">as_tibble</span>() <span class="sc">|&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>  <span class="fu">class</span>()</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>flights_stingy <span class="sc">|&gt;</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>  <span class="fu">as.data.frame</span>() <span class="sc">|&gt;</span></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a>  <span class="fu">class</span>()</span></code></pre></div>
</div>
<div id="comparison-1" class="section level3">
<h3>Comparison</h3>
<p>Stingy duckplyr frames behave like lazy tables in dbplyr and lazy
frames in dtplyr: the computation only starts when you
<em>explicitly</em> request it with <code>collect.duckplyr_df()</code>
or through other means. However, stingy duckplyr frames can be converted
to lavish ones at any time, and vice versa. In dtplyr and dbplyr, there
are no lavish frames: collection always needs to be explicit.</p>
</div>
</div>
<div id="thrift" class="section level2">
<h2>Thrift</h2>
<p>Thrifty is a compromise between stingy and lavish. Materialization is
allowed for data up to a certain size, measured in cells (values) and
rows in the resulting data frame.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">nrow</span>(flights)</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>flights_partial <span class="ot">&lt;-</span></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>  flights <span class="sc">|&gt;</span></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>  duckplyr<span class="sc">::</span><span class="fu">as_duckdb_tibble</span>(<span class="at">prudence =</span> <span class="st">&quot;thrifty&quot;</span>)</span></code></pre></div>
<p>With this setting, the data is materialized only if the result has
fewer than 1,000,000 cells (rows multiplied by columns).</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>flights_partial <span class="sc">|&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>  <span class="fu">select</span>(origin, dest, dep_delay, arr_delay) <span class="sc">|&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>  <span class="fu">nrow</span>()</span></code></pre></div>
<p>The original input is too large to be materialized, so the operation
fails. On the other hand, the result after aggregation is small enough
to be materialized:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>flights_partial <span class="sc">|&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>  <span class="fu">count</span>(origin) <span class="sc">|&gt;</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>  <span class="fu">nrow</span>()</span></code></pre></div>
<p>Thrifty is a good choice for data sets where the cost of
materializing the data is prohibitive only for large results. This is
the default for the ingestion functions like
<code>read_parquet_duckdb()</code>.</p>
</div>
<div id="conclusion" class="section level2">
<h2>Conclusion</h2>
<p>The duckplyr package provides</p>
<ul>
<li>a drop-in replacement for duckplyr, which necessitates “eager” data
frames that automatically materialize like in dplyr,</li>
<li>optimization by DuckDB, which means “lazy” evaluation where the data
is materialized at the latest possible stage.</li>
</ul>
<p>Automatic materialization can be dangerous for memory with large
data, so duckplyr provides a setting called <code>prudence</code> that
controls automatic materialization: is the data automatically
materialized <em>always</em> (“lavish” frames), <em>never</em> (“stingy”
frames) or <em>up to a certain size</em> (“thrifty” frames).</p>
<p>See <code>vignette(&quot;large&quot;)</code> for more details on working with
large data sets, <code>vignette(&quot;fallback&quot;)</code> for fallbacks to
dplyr, <code>vignette(&quot;limits&quot;)</code> for the operations supported by
duckplyr, and <code>vignette(&quot;duckdb&quot;)</code> for using DuckDB functions
directly.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
